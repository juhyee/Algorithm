<!-- https://school.programmers.co.kr/learn/courses/30/lessons/12926 -->

<!-- 시저 암호
문제 설명
어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 "AB"는 1만큼 밀면 "BC"가 되고, 3만큼 밀면 "DE"가 됩니다. "z"는 1만큼 밀면 "a"가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.

제한 조건
공백은 아무리 밀어도 공백입니다.
s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.
s의 길이는 8000이하입니다.
n은 1 이상, 25이하인 자연수입니다.
입출력 예
s	n	result
"AB"	1	"BC"
"z"	1	"a"
"a B z"	4	"e F d" -->


<!-- 내가 쓴 정답 -->
<script>
    function solution(array, commands) {
        var answer = [];

        for (let i = 0; i < commands.length; i++) {
            let num = array.slice(commands[i][0] - 1, commands[i][1]).sort((a, b) => a - b)
            answer.push(num[commands[i][2] - 1])
        }

        return answer
    }
</script>
<!-- 내가 쓴 정답 -->

<!-- 남이 쓴 정답 -01 -->
<script>
    function solution(array, commands) {
        return commands.map(v => {
            return array.slice(v[0] - 1, v[1]).sort((a, b) => a - b).slice(v[2] - 1, v[2])[0];
        });
    }
</script>
<!-- //남이 쓴 정답 -01 -->


<!-- 회고록
  메소드 map을 사용해서 풀고 싶었는데 아무리해도 안나와서 반복문으로 풀었다.
  다른 사람들이 map으로 푼 정답 보니깐 commands에 map을 활용하였는데 나는
  계속 array에 map으로 풀려니깐 안풀렸던 거 같다.

  for, if문에서 언제쯤 벗어날 수 있을런지...😅😅

  [내가 쓴 정답]
    1) commands 객체만큼 반복한다.
    2) 변수 num에 array 배열을 commands[i][0] 부터 commands[i][1] 까지만 slice한다.
    3) 배열 num을 sort를 활용하여 숫자가 적은 순서로 재배열을 해 준 뒤
    4)  answer에 num의 [commands[i][2] - 1]번째 객체를 push하여 return 해 준다.

  [남이 쓴 정답 -01]
    1) commands 배열을 map 메서드를 통해 아래( 2) ) 순으로 새로운 배열을 반환해 준다.
    2) commands의 첫번째 객체부터 마지막 객체(v) 순으로 [v][0] 부터 [v][1] 까지 slice한다.
    3) 배열 num을 sort를 활용하여 숫자가 적은 순서로 재배열을 해 준 뒤
    4) 다시 slice 메서드를 통해 (v[2] - 1, v[2]) 뒤 첫번째 객체만 return 해준다.

-->